@using Glide.Web.Features.Shared
<HtmxLayout Title="@Board.Name" BodyClass="board-page" ShowNavBar="true">
    <main>
        <div class="board-header">
            <a href="/dashboard" class="back-link" title="Back to Dashboard">←</a>
            <h2 class="board-title">@Board.Name</h2>
            <div class="label-filter">
                <button class="filter-button" id="filter-button" onclick="toggleLabelFilter(event)">Filter</button>
                <div class="label-filter-dropdown" id="label-filter-dropdown" style="display: none;">
                    <button type="button" class="filter-option" data-filter-id=""
                            onclick="filterByLabel(null, 'Show All')">Show All
                    </button>
                    <div id="filter-labels" hx-get="/boards/@Board.Id/labels?view=filter" hx-trigger="load"
                         hx-swap="innerHTML">
                        Loading labels...
                    </div>
                </div>
            </div>

            <div class="board-menu">
                <button class="board-menu-button" onclick="toggleBoardMenu(event)">⋮</button>
                <div class="board-menu-dropdown" id="board-menu-dropdown">
                    <div id="add-column-menu-item">
                        <button class="board-menu-item" onclick="showAddColumnForm(event)">Add column</button>
                    </div>
                    @if (Board.BoardUserView?.IsOwner ?? false)
                    {
                        <button class="board-menu-item" onclick="openBoardUserManagement('@Board.Id')">
                            Manage members
                        </button>
                    }
                    <button class="board-menu-item"
                            hx-get="/boards/@Board.Id/labels"
                            hx-target="body"
                            hx-swap="beforeend"
                            hx-on::after-request="document.body.style.overflow = 'hidden'; document.getElementById('board-menu-dropdown').classList.remove('show');">
                        Manage labels
                    </button>
                    <form id="add-column-form" class="add-column-form" style="display: none;"
                          novalidate
                          hx-post="/boards/@Board.Id/columns"
                          hx-target="#kanban-board"
                          hx-swap="innerHTML"
                          hx-on::after-request="handleAddColumnResponse(event)">
                        <input type="text" name="name" placeholder="Column name" required autocomplete="off"
                               class="add-column-input">
                        <div class="add-column-actions">
                            <button type="submit" class="btn-save">Add</button>
                            <button type="button" class="btn-cancel" onclick="hideAddColumnForm()">Cancel</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <div class="kanban-board" id="kanban-board"
             hx-get="/boards/@Board.Id/columns"
             hx-trigger="load"
             hx-swap="innerHTML">
            <div class="loading">Loading board...</div>
        </div>
    </main>

    <!-- Card Edit Modal -->
    <div id="card-modal" class="modal" onclick="closeModalOnBackdrop(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3>Edit Card</h3>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div id="modal-body" class="modal-body">
                <!-- Card edit form loaded via HTMX -->
            </div>
        </div>
    </div>

    <script>
        // Drag and drop functionality
        let draggedCard = null;
        let dropIndicator = null;
        let targetCard = null;
        let insertBefore = false;

        function dragCard(event) {
            draggedCard = event.target;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', event.target.dataset.cardId);

            // Create drop indicator if it doesn't exist
            if (!dropIndicator) {
                dropIndicator = document.createElement('div');
                dropIndicator.className = 'drop-indicator';
            }
        }

        function allowDrop(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';

            if (!draggedCard) return;

            // Check if we're over a card card
            const cardCard = event.target.closest('.card-card');

            if (cardCard && cardCard !== draggedCard) {
                // Calculate if mouse is in top or bottom half
                const rect = cardCard.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                insertBefore = event.clientY < midpoint;

                targetCard = cardCard;

                // Position the drop indicator
                if (insertBefore) {
                    cardCard.parentNode.insertBefore(dropIndicator, cardCard);
                } else {
                    if (cardCard.nextSibling) {
                        cardCard.parentNode.insertBefore(dropIndicator, cardCard.nextSibling);
                    } else {
                        cardCard.parentNode.appendChild(dropIndicator);
                    }
                }
            } else {
                // Over empty space in column
                const column = event.target.closest('.column');
                if (column) {
                    column.classList.add('drag-over');
                    const cardsContainer = column.querySelector('.column-cards');

                    // If no cards or over empty space, show indicator at bottom
                    const cards = cardsContainer.querySelectorAll('.card-card:not(.dragging)');
                    if (cards.length === 0) {
                        cardsContainer.appendChild(dropIndicator);
                        targetCard = null;
                        insertBefore = false;
                    }
                }
            }
        }

        function dropCard(event) {
            event.preventDefault();

            // Remove drop indicator
            if (dropIndicator && dropIndicator.parentNode) {
                dropIndicator.parentNode.removeChild(dropIndicator);
            }

            // Remove drag-over class from all columns
            document.querySelectorAll('.column').forEach(col => {
                col.classList.remove('drag-over');
            });

            if (!draggedCard) return;

            const column = event.target.closest('.column');
            if (!column) return;

            const targetColumnId = column.dataset.columnId;
            const cardId = draggedCard.dataset.cardId;

            // Calculate target position
            const cardsContainer = column.querySelector('.column-cards');
            let targetPosition = 0;

            if (targetCard && targetCard !== draggedCard) {
                // Get all cards in the target column (excluding the dragged one)
                const allCards = Array.from(cardsContainer.querySelectorAll('.card-card:not(.dragging)'));
                const targetIndex = allCards.indexOf(targetCard);

                if (targetIndex !== -1) {
                    targetPosition = insertBefore ? targetIndex : targetIndex + 1;
                }
            } else {
                // Dropping at the end
                const allCards = cardsContainer.querySelectorAll('.card-card:not(.dragging)');
                targetPosition = allCards.length;
            }

            // Update DOM immediately for responsive feel
            if (targetCard && targetCard !== draggedCard) {
                if (insertBefore) {
                    cardsContainer.insertBefore(draggedCard, targetCard);
                } else {
                    if (targetCard.nextSibling) {
                        cardsContainer.insertBefore(draggedCard, targetCard.nextSibling);
                    } else {
                        cardsContainer.appendChild(draggedCard);
                    }
                }
            } else {
                cardsContainer.appendChild(draggedCard);
            }

            // Update the card's column_id data attribute
            draggedCard.dataset.columnId = targetColumnId;

            // Send the move request to the server
            const formData = new FormData();
            formData.append('column_id', targetColumnId);
            formData.append('position', targetPosition);

            fetch('/cards/' + cardId + '/move', {
                method: 'PUT',
                body: formData
            }).then(response => {
                if (!response.ok) {
                    // Revert on error - reload the board
                    htmx.trigger('#kanban-board', 'load');
                } else {
                    // Update card counts
                    updateCardCounts();
                }
            }).catch(() => {
                htmx.trigger('#kanban-board', 'load');
            });

            draggedCard.classList.remove('dragging');
            draggedCard = null;
            targetCard = null;
        }

        function updateCardCounts() {
            document.querySelectorAll('.column').forEach(column => {
                const cards = column.querySelectorAll('.card-card');
                const countBadge = column.querySelector('.card-count');
                if (countBadge) {
                    countBadge.textContent = cards.length;
                }
            });
        }

        // Remove drag-over class when leaving a column
        document.addEventListener('dragleave', function (event) {
            const column = event.target.closest('.column');
            if (column && !column.contains(event.relatedTarget)) {
                column.classList.remove('drag-over');
            }
        });

        // Remove dragging class if drag ends unexpectedly
        document.addEventListener('dragend', function () {
            if (draggedCard) {
                draggedCard.classList.remove('dragging');
                draggedCard = null;
            }
            if (dropIndicator && dropIndicator.parentNode) {
                dropIndicator.parentNode.removeChild(dropIndicator);
            }
            targetCard = null;
            document.querySelectorAll('.column').forEach(col => {
                col.classList.remove('drag-over');
            });
        });

        // Clear input after adding card
        document.body.addEventListener('htmx:afterRequest', function (event) {
            if (event.detail.requestConfig &&
                event.detail.requestConfig.verb === 'post' &&
                event.detail.requestConfig.path.includes('/cards')) {
                if (event.detail.successful) {
                    const form = event.detail.elt;
                    if (form && form.tagName === 'FORM') {
                        form.reset();
                        updateCardCounts();
                    }
                }
            }
        });

        // Update counts after delete
        document.body.addEventListener('htmx:afterSwap', function (event) {
            if (event.detail.requestConfig &&
                event.detail.requestConfig.verb === 'delete') {
                updateCardCounts();
            }
        });

        // Modal functions
        let currentCardId = null;

        function openCardModal(cardId) {
            currentCardId = cardId;
            const modal = document.getElementById('card-modal');
            const modalBody = document.getElementById('modal-body');

            // Show modal with loading state
            modal.classList.add('modal-open');
            modalBody.innerHTML = '<div class="loading">Loading...</div>';
            document.body.style.overflow = 'hidden';

            // Fetch card edit form
            fetch('/cards/' + cardId + '/edit')
                .then(r => r.text())
                .then(html => {
                    modalBody.innerHTML = html;
                    htmx.process(modalBody);
                });
        }

        function closeModal() {
            const modal = document.getElementById('card-modal');
            modal.classList.remove('modal-open');
            document.body.style.overflow = '';
            currentCardId = null;

            // Refresh the board to show any changes
            htmx.trigger('#kanban-board', 'load');
        }

        function closeModalOnBackdrop(event) {
            if (event.target.id === 'card-modal') {
                closeModal();
            }
        }

        // Close modal on Escape key
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('card-modal');
                if (modal.classList.contains('modal-open')) {
                    closeModal();
                }
            }
        });

        // Create a new label for a card (inline creation from card modal)
        function createLabelForCard(cardId, boardId) {
            const nameInput = document.getElementById('new-label-name-' + cardId);

            const name = nameInput.value.trim();
            if (!name) {
                alert('Please enter a label name');
                return;
            }

            const formData = new FormData();
            formData.append('board_id', boardId);
            formData.append('name', name);

            fetch('/labels', {
                method: 'POST',
                body: formData
            }).then(response => {
                if (response.ok) {
                    return response.json();
                }
            }).then(label => {
                if (label) {
                    // Add the label to the card using HTMX to properly handle OOB swaps
                    htmx.ajax('POST', '/cards/' + cardId + '/labels', {
                        target: '#label-options-' + cardId,
                        swap: 'innerHTML',
                        values: {label_id: label.id}
                    }).then(() => {
                        // Clear the input field
                        nameInput.value = '';
                    });
                }
            });
        }

        // Toggle label picker dropdown
        function toggleLabelPicker(cardId) {
            const menu = document.getElementById('label-picker-menu-' + cardId);
            if (menu.style.display === 'none') {
                menu.style.display = 'block';
            } else {
                menu.style.display = 'none';
            }
        }


        // Label filtering
        let currentLabelFilter = null;

        function toggleLabelFilter(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('label-filter-dropdown');
            dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        }

        function filterByLabel(labelId, labelName) {
            currentLabelFilter = labelId;
            const cards = document.querySelectorAll('.card-card');

            cards.forEach(card => {
                if (labelId === null) {
                    // Show all cards
                    card.style.display = '';
                } else {
                    // Check if card has the label
                    const hasLabel = card.querySelector(`[data-label-id="${labelId}"]`);
                    card.style.display = hasLabel ? '' : 'none';
                }
            });

            // Update filter button text
            const filterButton = document.getElementById('filter-button');
            if (labelId === null) {
                filterButton.textContent = 'Filter';
            } else {
                filterButton.textContent = `Filter: ${labelName}`;
            }

            // Update active state on filter options
            document.querySelectorAll('.filter-option').forEach(option => {
                const optionId = option.getAttribute('data-filter-id');
                if ((labelId === null && optionId === '') || optionId === labelId) {
                    option.classList.add('active');
                } else {
                    option.classList.remove('active');
                }
            });

            // Update card counts
            updateCardCounts();

            // Close the filter dropdown
            document.getElementById('label-filter-dropdown').style.display = 'none';
        }

        // Close filter dropdown when clicking outside
        document.addEventListener('click', function (event) {
            if (!event.target.closest('.label-filter')) {
                const dropdown = document.getElementById('label-filter-dropdown');
                if (dropdown) {
                    dropdown.style.display = 'none';
                }
            }
        });

        let markdownDebounceTimer = null;

        function updateMarkdownPreview() {
            clearTimeout(markdownDebounceTimer);

            markdownDebounceTimer = setTimeout(() => {
                const textarea = document.getElementById('card-description');
                const previewContent = document.getElementById('preview-content');
                const markdown = textarea.value.trim();

                if (!markdown) {
                    previewContent.innerHTML = '';
                    return;
                }

                // Show loading state
                previewContent.innerHTML = '<em>Loading preview...</em>';

                const formData = new FormData();
                formData.append('markdown', markdown);

                fetch('/cards/markdown', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => response.text())
                    .then(html => {
                        previewContent.innerHTML = html;
                    })
                    .catch(() => {
                        previewContent.innerHTML = '<em style="color: red;">Failed to load preview</em>';
                    });

            }, 500);
        }

        // Board menu toggle
        function toggleBoardMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('board-menu-dropdown');
            const form = document.getElementById('add-column-form');

            // Don't close menu if form is visible
            if (form.style.display === 'block') {
                return;
            }

            dropdown.classList.toggle('show');
        }

        // Close board menu when clicking outside
        document.addEventListener('click', function (event) {
            const dropdown = document.getElementById('board-menu-dropdown');
            const form = document.getElementById('add-column-form');

            // Don't close if form is visible
            if (form && form.style.display === 'block') {
                return;
            }

            // Don't close if clicking inside the board menu area
            if (event.target.closest('.board-menu')) {
                return;
            }

            if (dropdown && dropdown.classList.contains('show')) {
                dropdown.classList.remove('show');
            }
        });

        // Add column form functions
        function showAddColumnForm(event) {
            event.preventDefault();
            event.stopPropagation();

            document.getElementById('add-column-menu-item').style.display = 'none';
            const form = document.getElementById('add-column-form');
            form.style.display = 'block';

            // Focus the input
            const input = form.querySelector('input[name="name"]');
            setTimeout(() => input.focus(), 0);
        }

        function hideAddColumnForm() {
            const form = document.getElementById('add-column-form');
            const dropdown = document.getElementById('board-menu-dropdown');

            form.style.display = 'none';
            form.reset();
            document.getElementById('add-column-menu-item').style.display = 'block';

            // Close the menu dropdown as well
            dropdown.classList.remove('show');
        }

        function handleAddColumnResponse(event) {
            if (event.detail.successful) {
                // Close menu and reset form
                const dropdown = document.getElementById('board-menu-dropdown');
                dropdown.classList.remove('show');
                hideAddColumnForm();
            }
        }

        // Column menu functions
        function toggleColumnMenu(event, columnId) {
            event.stopPropagation();
            const dropdown = document.getElementById('column-menu-dropdown-' + columnId);

            // Close all other column menus
            document.querySelectorAll('.column-menu-dropdown').forEach(menu => {
                if (menu.id !== 'column-menu-dropdown-' + columnId) {
                    menu.classList.remove('show');
                }
            });

            dropdown.classList.toggle('show');
        }

        function validateColumnDelete(event, button) {
            const cardCount = parseInt(button.dataset.cardCount);

            if (cardCount > 0) {
                event.preventDefault();
                event.stopPropagation();
                alert('Cannot delete column: it contains ' + cardCount + ' card(s). Please move or delete the cards first.');
                return false;
            }

            return true;
        }

        // Close column menus after successful delete
        document.body.addEventListener('htmx:afterSwap', function (event) {
            if (event.detail.requestConfig &&
                event.detail.requestConfig.verb === 'delete' &&
                event.detail.requestConfig.path.includes('/columns/')) {
                document.querySelectorAll('.column-menu-dropdown').forEach(menu => {
                    menu.classList.remove('show');
                });
            }
        });

        // Close column menus when clicking outside
        document.addEventListener('click', function (event) {
            if (!event.target.closest('.column-menu')) {
                document.querySelectorAll('.column-menu-dropdown').forEach(menu => {
                    menu.classList.remove('show');
                });
            }
        });
    </script>
    <BoardUserManagement BoardId="@Board.Id"/>
</HtmxLayout>

@code
{
    [Parameter] public required BoardView Board { get; init; }
}
