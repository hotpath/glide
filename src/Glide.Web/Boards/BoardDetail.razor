@using Glide.Web.Features.Shared
<HtmxLayout Title="@Board.Name" BodyClass="board-page">
    <main>
        <div class="board-header">
            <a href="/dashboard" class="back-link" title="Back to Dashboard">←</a>
            <h2 class="board-title">@Board.Name</h2>
            <div class="board-menu">
                <button class="board-menu-button" onclick="toggleBoardMenu(event)">⋮</button>
                <div class="board-menu-dropdown" id="board-menu-dropdown">
                    <div id="add-column-menu-item">
                        <button class="board-menu-item" onclick="showAddColumnForm(event)">Add column</button>
                    </div>
                    <form id="add-column-form" class="add-column-form" style="display: none;"
                          novalidate
                          hx-post="/boards/@Board.Id/swimlanes"
                          hx-target="#kanban-board"
                          hx-swap="innerHTML"
                          hx-on::after-request="handleAddColumnResponse(event)">
                        <input type="text" name="name" placeholder="Column name" required autocomplete="off"
                               class="add-column-input">
                        <div class="add-column-actions">
                            <button type="submit" class="btn-save">Add</button>
                            <button type="button" class="btn-cancel" onclick="hideAddColumnForm()">Cancel</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <div class="kanban-board" id="kanban-board"
             hx-get="/boards/@Board.Id/swimlanes"
             hx-trigger="load"
             hx-swap="innerHTML">
            <div class="loading">Loading board...</div>
        </div>
    </main>

    <!-- Task Edit Modal -->
    <div id="task-modal" class="modal" onclick="closeModalOnBackdrop(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3>Edit Task</h3>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div id="modal-body" class="modal-body">
                <!-- Task edit form loaded via HTMX -->
            </div>
        </div>
    </div>

    <script>
        // Drag and drop functionality
        let draggedTask = null;
        let dropIndicator = null;
        let targetTask = null;
        let insertBefore = false;

        function dragTask(event) {
            draggedTask = event.target;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', event.target.dataset.taskId);

            // Create drop indicator if it doesn't exist
            if (!dropIndicator) {
                dropIndicator = document.createElement('div');
                dropIndicator.className = 'drop-indicator';
            }
        }

        function allowDrop(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';

            if (!draggedTask) return;

            // Check if we're over a task card
            const taskCard = event.target.closest('.task-card');

            if (taskCard && taskCard !== draggedTask) {
                // Calculate if mouse is in top or bottom half
                const rect = taskCard.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                insertBefore = event.clientY < midpoint;

                targetTask = taskCard;

                // Position the drop indicator
                if (insertBefore) {
                    taskCard.parentNode.insertBefore(dropIndicator, taskCard);
                } else {
                    if (taskCard.nextSibling) {
                        taskCard.parentNode.insertBefore(dropIndicator, taskCard.nextSibling);
                    } else {
                        taskCard.parentNode.appendChild(dropIndicator);
                    }
                }
            } else {
                // Over empty space in column
                const column = event.target.closest('.swimlane-column');
                if (column) {
                    column.classList.add('drag-over');
                    const tasksContainer = column.querySelector('.swimlane-tasks');

                    // If no tasks or over empty space, show indicator at bottom
                    const tasks = tasksContainer.querySelectorAll('.task-card:not(.dragging)');
                    if (tasks.length === 0) {
                        tasksContainer.appendChild(dropIndicator);
                        targetTask = null;
                        insertBefore = false;
                    }
                }
            }
        }

        function dropTask(event) {
            event.preventDefault();

            // Remove drop indicator
            if (dropIndicator && dropIndicator.parentNode) {
                dropIndicator.parentNode.removeChild(dropIndicator);
            }

            // Remove drag-over class from all columns
            document.querySelectorAll('.swimlane-column').forEach(col => {
                col.classList.remove('drag-over');
            });

            if (!draggedTask) return;

            const column = event.target.closest('.swimlane-column');
            if (!column) return;

            const targetSwimlaneId = column.dataset.swimlaneId;
            const taskId = draggedTask.dataset.taskId;

            // Calculate target position
            const tasksContainer = column.querySelector('.swimlane-tasks');
            let targetPosition = 0;

            if (targetTask && targetTask !== draggedTask) {
                // Get all tasks in the target swimlane (excluding the dragged one)
                const allTasks = Array.from(tasksContainer.querySelectorAll('.task-card:not(.dragging)'));
                const targetIndex = allTasks.indexOf(targetTask);

                if (targetIndex !== -1) {
                    targetPosition = insertBefore ? targetIndex : targetIndex + 1;
                }
            } else {
                // Dropping at the end
                const allTasks = tasksContainer.querySelectorAll('.task-card:not(.dragging)');
                targetPosition = allTasks.length;
            }

            // Update DOM immediately for responsive feel
            if (targetTask && targetTask !== draggedTask) {
                if (insertBefore) {
                    tasksContainer.insertBefore(draggedTask, targetTask);
                } else {
                    if (targetTask.nextSibling) {
                        tasksContainer.insertBefore(draggedTask, targetTask.nextSibling);
                    } else {
                        tasksContainer.appendChild(draggedTask);
                    }
                }
            } else {
                tasksContainer.appendChild(draggedTask);
            }

            // Update the task's swimlane_id data attribute
            draggedTask.dataset.swimlaneId = targetSwimlaneId;

            // Send the move request to the server
            const formData = new FormData();
            formData.append('swimlane_id', targetSwimlaneId);
            formData.append('position', targetPosition);

            fetch('/tasks/' + taskId + '/move', {
                method: 'PUT',
                body: formData
            }).then(response => {
                if (!response.ok) {
                    // Revert on error - reload the board
                    htmx.trigger('#kanban-board', 'load');
                } else {
                    // Update task counts
                    updateTaskCounts();
                }
            }).catch(() => {
                htmx.trigger('#kanban-board', 'load');
            });

            draggedTask.classList.remove('dragging');
            draggedTask = null;
            targetTask = null;
        }

        function updateTaskCounts() {
            document.querySelectorAll('.swimlane-column').forEach(column => {
                const tasks = column.querySelectorAll('.task-card');
                const countBadge = column.querySelector('.task-count');
                if (countBadge) {
                    countBadge.textContent = tasks.length;
                }
            });
        }

        // Remove drag-over class when leaving a column
        document.addEventListener('dragleave', function (event) {
            const column = event.target.closest('.swimlane-column');
            if (column && !column.contains(event.relatedTarget)) {
                column.classList.remove('drag-over');
            }
        });

        // Remove dragging class if drag ends unexpectedly
        document.addEventListener('dragend', function () {
            if (draggedTask) {
                draggedTask.classList.remove('dragging');
                draggedTask = null;
            }
            if (dropIndicator && dropIndicator.parentNode) {
                dropIndicator.parentNode.removeChild(dropIndicator);
            }
            targetTask = null;
            document.querySelectorAll('.swimlane-column').forEach(col => {
                col.classList.remove('drag-over');
            });
        });

        // Clear input after adding task
        document.body.addEventListener('htmx:afterRequest', function (event) {
            if (event.detail.requestConfig &&
                event.detail.requestConfig.verb === 'post' &&
                event.detail.requestConfig.path.includes('/tasks')) {
                if (event.detail.successful) {
                    const form = event.detail.elt;
                    if (form && form.tagName === 'FORM') {
                        form.reset();
                        updateTaskCounts();
                    }
                }
            }
        });

        // Update counts after delete
        document.body.addEventListener('htmx:afterSwap', function (event) {
            if (event.detail.requestConfig &&
                event.detail.requestConfig.verb === 'delete') {
                updateTaskCounts();
            }
        });

        // Modal functions
        let currentTaskId = null;

        function openTaskModal(taskId) {
            currentTaskId = taskId;
            const modal = document.getElementById('task-modal');
            const modalBody = document.getElementById('modal-body');

            // Show modal with loading state
            modal.classList.add('modal-open');
            modalBody.innerHTML = '<div class="loading">Loading...</div>';
            document.body.style.overflow = 'hidden';

            // Fetch task edit form
            fetch('/tasks/' + taskId + '/edit')
                .then(r => r.text())
                .then(html => {
                    modalBody.innerHTML = html;
                    htmx.process(modalBody);
                });
        }

        function closeModal() {
            const modal = document.getElementById('task-modal');
            modal.classList.remove('modal-open');
            document.body.style.overflow = '';
            currentTaskId = null;

            // Refresh the board to show any changes
            htmx.trigger('#kanban-board', 'load');
        }

        function closeModalOnBackdrop(event) {
            if (event.target.id === 'task-modal') {
                closeModal();
            }
        }

        // Close modal on Escape key
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('task-modal');
                if (modal.classList.contains('modal-open')) {
                    closeModal();
                }
            }
        });

        // Create a new label for a board
        function createLabel(boardId, taskId) {
            const nameInput = document.getElementById('new-label-name-' + taskId);
            const colorInput = document.getElementById('new-label-color-' + taskId);

            const name = nameInput.value.trim();
            if (!name) {
                return;
            }

            const color = colorInput.value;

            fetch('/boards/' + boardId + '/labels', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: 'name=' + encodeURIComponent(name) + '&color=' + encodeURIComponent(color)
            }).then(response => {
                if (response.ok) {
                    // Refresh the modal content to show the new label
                    fetch('/tasks/' + taskId + '/edit')
                        .then(r => r.text())
                        .then(html => {
                            document.getElementById('modal-body').innerHTML = html;
                            htmx.process(document.getElementById('modal-body'));
                        });
                }
            });
        }

        let markdownDebounceTimer = null;

        function updateMarkdownPreview() {
            clearTimeout(markdownDebounceTimer);

            markdownDebounceTimer = setTimeout(() => {
                const textarea = document.getElementById('task-description');
                const previewContent = document.getElementById('preview-content');
                const markdown = textarea.value.trim();

                if (!markdown) {
                    previewContent.innerHTML = '';
                    return;
                }

                // Show loading state
                previewContent.innerHTML = '<em>Loading preview...</em>';

                const formData = new FormData();
                formData.append('markdown', markdown);

                fetch('/tasks/markdown', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => response.text())
                    .then(html => {
                        previewContent.innerHTML = html;
                    })
                    .catch(() => {
                        previewContent.innerHTML = '<em style="color: red;">Failed to load preview</em>';
                    });

            }, 500);
        }

        // Board menu toggle
        function toggleBoardMenu(event) {
            event.stopPropagation();
            const dropdown = document.getElementById('board-menu-dropdown');
            const form = document.getElementById('add-column-form');

            // Don't close menu if form is visible
            if (form.style.display === 'block') {
                return;
            }

            dropdown.classList.toggle('show');
        }

        // Close board menu when clicking outside
        document.addEventListener('click', function (event) {
            const dropdown = document.getElementById('board-menu-dropdown');
            const form = document.getElementById('add-column-form');

            // Don't close if form is visible
            if (form && form.style.display === 'block') {
                return;
            }

            if (dropdown && dropdown.classList.contains('show')) {
                dropdown.classList.remove('show');
            }
        });

        // Add column form functions
        function showAddColumnForm(event) {
            event.preventDefault();
            event.stopPropagation();

            document.getElementById('add-column-menu-item').style.display = 'none';
            const form = document.getElementById('add-column-form');
            form.style.display = 'block';

            // Focus the input
            const input = form.querySelector('input[name="name"]');
            setTimeout(() => input.focus(), 0);
        }

        function hideAddColumnForm() {
            const form = document.getElementById('add-column-form');
            const dropdown = document.getElementById('board-menu-dropdown');

            form.style.display = 'none';
            form.reset();
            document.getElementById('add-column-menu-item').style.display = 'block';

            // Close the menu dropdown as well
            dropdown.classList.remove('show');
        }

        function handleAddColumnResponse(event) {
            if (event.detail.successful) {
                // Close menu and reset form
                const dropdown = document.getElementById('board-menu-dropdown');
                dropdown.classList.remove('show');
                hideAddColumnForm();
            }
        }
    </script>
</HtmxLayout>

@code
{
    [Parameter] public required BoardView Board { get; init; }
}
