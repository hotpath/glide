@using Glide.Data.Boards
@using Glide.Web.Features.Shared
<HtmxLayout Title="@Board.Name" BodyClass="board-page">
    <main>
        <div class="board-header">
            <a href="/dashboard" class="back-link" title="Back to Dashboard">‚Üê</a>
            <h2 class="board-title">@Board.Name</h2>
        </div>

        <div class="kanban-board" id="kanban-board"
             hx-get="/boards/@Board.Id/swimlanes"
             hx-trigger="load"
             hx-swap="innerHTML">
            <div class="loading">Loading board...</div>
        </div>
    </main>

    <!-- Task Edit Modal -->
    <div id="task-modal" class="modal" onclick="closeModalOnBackdrop(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3>Edit Task</h3>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div id="modal-body" class="modal-body">
                <!-- Task edit form loaded via HTMX -->
            </div>
        </div>
    </div>

    <script>
        // Drag and drop functionality
        let draggedTask = null;

        function dragTask(event) {
            draggedTask = event.target;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', event.target.dataset.taskId);
        }

        function allowDrop(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';

            const column = event.target.closest('.swimlane-column');
            if (column) {
                column.classList.add('drag-over');
            }
        }

        function dropTask(event) {
            event.preventDefault();

            // Remove drag-over class from all columns
            document.querySelectorAll('.swimlane-column').forEach(col => {
                col.classList.remove('drag-over');
            });

            if (!draggedTask) return;

            const column = event.target.closest('.swimlane-column');
            if (!column) return;

            const targetSwimlaneId = column.dataset.swimlaneId;
            const taskId = draggedTask.dataset.taskId;
            const currentSwimlaneId = draggedTask.dataset.swimlaneId;

            // Only move if dropping on a different swimlane
            if (targetSwimlaneId !== currentSwimlaneId) {
                // Move the task card to the new column
                const tasksContainer = column.querySelector('.swimlane-tasks');
                tasksContainer.appendChild(draggedTask);

                // Update the task's swimlane_id data attribute
                draggedTask.dataset.swimlaneId = targetSwimlaneId;

                // Send the move request to the server
                const formData = new FormData();
                formData.append('swimlane_id', targetSwimlaneId);

                fetch('/tasks/' + taskId + '/move', {
                    method: 'PUT',
                    body: formData
                }).then(response => {
                    if (!response.ok) {
                        // Revert on error - reload the board
                        htmx.trigger('#kanban-board', 'load');
                    } else {
                        // Update task counts
                        updateTaskCounts();
                    }
                }).catch(() => {
                    htmx.trigger('#kanban-board', 'load');
                });
            }

            draggedTask.classList.remove('dragging');
            draggedTask = null;
        }

        function updateTaskCounts() {
            document.querySelectorAll('.swimlane-column').forEach(column => {
                const tasks = column.querySelectorAll('.task-card');
                const countBadge = column.querySelector('.task-count');
                if (countBadge) {
                    countBadge.textContent = tasks.length;
                }
            });
        }

        // Remove drag-over class when leaving a column
        document.addEventListener('dragleave', function (event) {
            const column = event.target.closest('.swimlane-column');
            if (column && !column.contains(event.relatedTarget)) {
                column.classList.remove('drag-over');
            }
        });

        // Remove dragging class if drag ends unexpectedly
        document.addEventListener('dragend', function () {
            if (draggedTask) {
                draggedTask.classList.remove('dragging');
                draggedTask = null;
            }
            document.querySelectorAll('.swimlane-column').forEach(col => {
                col.classList.remove('drag-over');
            });
        });

        // Clear input after adding task
        document.body.addEventListener('htmx:afterRequest', function (event) {
            if (event.detail.requestConfig &&
                event.detail.requestConfig.verb === 'post' &&
                event.detail.requestConfig.path.includes('/tasks')) {
                if (event.detail.successful) {
                    const form = event.detail.elt;
                    if (form && form.tagName === 'FORM') {
                        form.reset();
                        updateTaskCounts();
                    }
                }
            }
        });

        // Update counts after delete
        document.body.addEventListener('htmx:afterSwap', function (event) {
            if (event.detail.requestConfig &&
                event.detail.requestConfig.verb === 'delete') {
                updateTaskCounts();
            }
        });

        // Modal functions
        let currentTaskId = null;

        function openTaskModal(taskId) {
            currentTaskId = taskId;
            const modal = document.getElementById('task-modal');
            const modalBody = document.getElementById('modal-body');

            // Show modal with loading state
            modal.classList.add('modal-open');
            modalBody.innerHTML = '<div class="loading">Loading...</div>';
            document.body.style.overflow = 'hidden';

            // Fetch task edit form
            fetch('/tasks/' + taskId + '/edit')
                .then(r => r.text())
                .then(html => {
                    modalBody.innerHTML = html;
                    htmx.process(modalBody);
                });
        }

        function closeModal() {
            const modal = document.getElementById('task-modal');
            modal.classList.remove('modal-open');
            document.body.style.overflow = '';
            currentTaskId = null;

            // Refresh the board to show any changes
            htmx.trigger('#kanban-board', 'load');
        }

        function closeModalOnBackdrop(event) {
            if (event.target.id === 'task-modal') {
                closeModal();
            }
        }

        // Close modal on Escape key
        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('task-modal');
                if (modal.classList.contains('modal-open')) {
                    closeModal();
                }
            }
        });

        // Create a new label for a board
        function createLabel(boardId, taskId) {
            const nameInput = document.getElementById('new-label-name-' + taskId);
            const colorInput = document.getElementById('new-label-color-' + taskId);

            const name = nameInput.value.trim();
            if (!name) {
                return;
            }

            const color = colorInput.value;

            fetch('/boards/' + boardId + '/labels', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: 'name=' + encodeURIComponent(name) + '&color=' + encodeURIComponent(color)
            }).then(response => {
                if (response.ok) {
                    // Refresh the modal content to show the new label
                    fetch('/tasks/' + taskId + '/edit')
                        .then(r => r.text())
                        .then(html => {
                            document.getElementById('modal-body').innerHTML = html;
                            htmx.process(document.getElementById('modal-body'));
                        });
                }
            });
        }

        let markdownDebounceTimer = null;

        function updateMarkdownPreview() {
            clearTimeout(markdownDebounceTimer);

            markdownDebounceTimer = setTimeout(() => {
                const textarea = document.getElementById('task-description');
                const previewContent = document.getElementById('preview-content');
                const markdown = textarea.value.trim();

                if (!markdown) {
                    previewContent.innerHTML = '';
                    return;
                }

                // Show loading state
                previewContent.innerHTML = '<em>Loading preview...</em>';

                const formData = new FormData();
                formData.append('markdown', markdown);

                fetch('/tasks/markdown', {
                    method: 'POST',
                    body: formData
                })
                    .then(response => response.text())
                    .then(html => {
                        previewContent.innerHTML = html;
                    })
                    .catch(error => {
                        previewContent.innerHTML = '<em style="color: red;">Failed to load preview</em>';
                    });

            }, 500);
        }
    </script>
</HtmxLayout>

@code
{
    [Parameter] public required Board Board { get; init; }
}
